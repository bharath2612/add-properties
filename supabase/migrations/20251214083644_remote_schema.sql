create extension if not exists "http" with schema "public";

create extension if not exists "pg_trgm" with schema "public";

create extension if not exists "postgis" with schema "public";

create extension if not exists "vector" with schema "public";

create sequence "public"."accounts_id_seq";

create sequence "public"."asset_migration_jobs_id_seq";

create sequence "public"."data_sources_id_seq";

create sequence "public"."facilities_id_seq";

create sequence "public"."partner_developers_id_seq";

create sequence "public"."partner_ingest_tasks_id_seq";

create sequence "public"."partner_ingest_tracker_id_seq";

create sequence "public"."properties_id_seq";

create sequence "public"."property_buildings_id_seq";

create sequence "public"."property_payment_plans_id_seq";

create sequence "public"."property_unit_blocks_id_seq";

create sequence "public"."saved_searches_id_seq";





























  create table "public"."accounts" (
    "id" bigint not null default nextval('accounts_id_seq'::regclass),
    "user_id" uuid not null,
    "email" text not null,
    "first_name" text,
    "last_name" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "avatar_url" text,
    "phone_number" text,
    "guide" boolean not null default false,
    "email_notifications" boolean default false,
    "phone_notifications" boolean default false,
    "mail_domain" text default ''::text
      );



  create table "public"."asset_migration_jobs" (
    "id" bigint not null default nextval('asset_migration_jobs_id_seq'::regclass),
    "property_id" integer not null,
    "asset_type" text not null,
    "original_url" text not null,
    "migrated_url" text,
    "status" text not null default 'pending'::text,
    "error_message" text,
    "retry_count" integer default 0,
    "file_size_bytes" bigint,
    "file_mime_type" text,
    "created_at" timestamp with time zone not null default now(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone
      );



  create table "public"."bookmarks" (
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default gen_random_uuid(),
    "property_id" integer not null
      );



  create table "public"."chat_feedback" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "chat_id" uuid not null,
    "message_index" integer not null,
    "message_content" text,
    "account_id" uuid,
    "feedback" text not null,
    "feedback_text" text
      );


alter table "public"."chat_feedback" enable row level security;


  create table "public"."chat_history" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone default now(),
    "session_id" uuid not null default gen_random_uuid(),
    "account_id" uuid default gen_random_uuid(),
    "chat" json,
    "title" text,
    "chat_id" uuid not null default gen_random_uuid(),
    "chat_markdown" json
      );



  create table "public"."data_sources" (
    "id" smallint not null default nextval('data_sources_id_seq'::regclass),
    "code" text not null,
    "name" text not null,
    "active" boolean not null default true,
    "created_at" timestamp with time zone default now()
      );



  create table "public"."facilities" (
    "id" integer not null default nextval('facilities_id_seq'::regclass),
    "name" text not null
      );



  create table "public"."guest_history" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "history" jsonb not null default '[]'::jsonb,
    "session_id" text,
    "ip_hash" text,
    "user_agent" text
      );



  create table "public"."partner_developers" (
    "id" integer not null default nextval('partner_developers_id_seq'::regclass),
    "source_id" smallint,
    "name" text not null,
    "description" text,
    "email" text,
    "website" text,
    "office_address" text,
    "logo_url" text,
    "working_hours" jsonb,
    "raw_data" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."partner_ingest_tasks" (
    "id" bigint not null default nextval('partner_ingest_tasks_id_seq'::regclass),
    "source_id" smallint not null,
    "external_id" text not null,
    "status" text not null default 'pending'::text,
    "attempts" integer not null default 0,
    "last_error" text,
    "created_at" timestamp with time zone default now(),
    "claimed_at" timestamp with time zone,
    "updated_at" timestamp with time zone not null default now(),
    "raw_list" jsonb,
    "raw_detail" jsonb
      );



  create table "public"."partner_ingest_tracker" (
    "id" integer not null default nextval('partner_ingest_tracker_id_seq'::regclass),
    "source_id" smallint not null,
    "last_page_processed" integer not null default 0,
    "total_pages" integer,
    "last_run_at" timestamp with time zone,
    "status" text default 'active'::text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );



  create table "public"."properties" (
    "id" integer not null default nextval('properties_id_seq'::regclass),
    "source_id" smallint,
    "external_id" text not null,
    "slug" text,
    "name" text not null,
    "area" text,
    "city" text,
    "country" text,
    "developer_id" integer,
    "status" text,
    "readiness" numeric,
    "sale_status" text,
    "completion_datetime" timestamp with time zone,
    "min_price_aed" numeric,
    "max_price_aed" numeric,
    "price_currency" text default 'AED'::text,
    "min_area" numeric,
    "max_area" numeric,
    "area_unit" text default 'sqft'::text,
    "furnishing" text,
    "service_charge" text,
    "parking" text,
    "has_escrow" boolean default false,
    "post_handover" boolean default false,
    "is_partner_project" boolean default false,
    "coordinates_text" text,
    "overview" text,
    "website" text,
    "video_url" text,
    "brochure_url" text,
    "layouts_pdf" text,
    "raw_data" jsonb,
    "content_hash" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "internal_slug" text,
    "brochure_url_original" text,
    "brochure_url_migrated" text,
    "layouts_pdf_original" text,
    "layouts_pdf_migrated" text,
    "location" geography(Point,4326),
    "permit_id" text
      );



  create table "public"."property_buildings" (
    "id" integer not null default nextval('property_buildings_id_seq'::regclass),
    "property_id" integer not null,
    "external_id" text,
    "name" text,
    "description" text,
    "completion_date" text,
    "image_url" text,
    "raw_data" jsonb,
    "created_at" timestamp with time zone not null default now()
      );



  create table "public"."property_facilities" (
    "property_id" integer not null,
    "facility_id" integer not null,
    "image_url" text,
    "image_source" text
      );



  create table "public"."property_images" (
    "property_id" integer not null,
    "image_url" text not null,
    "type" integer,
    "source_id" smallint,
    "category" text,
    "display_order" integer default 0,
    "name" text,
    "path" text,
    "mime" text,
    "size" integer,
    "width" integer,
    "height" integer,
    "image_source" text,
    "new_url" text
      );



  create table "public"."property_map_points" (
    "id" bigint not null,
    "property_id" integer,
    "source_id" smallint not null,
    "name" text not null,
    "distance_km" numeric
      );



  create table "public"."property_payment_plans" (
    "id" bigint not null default nextval('property_payment_plans_id_seq'::regclass),
    "property_id" integer not null,
    "plan_name" text not null,
    "months_after_handover" integer default 0,
    "payments" jsonb not null,
    "created_at" timestamp with time zone not null default now()
      );



  create table "public"."property_unit_blocks" (
    "id" bigint not null default nextval('property_unit_blocks_id_seq'::regclass),
    "property_id" integer,
    "source_id" smallint,
    "external_id" text,
    "name" text,
    "normalized_type" text,
    "area_unit" text,
    "area_from_m2" numeric,
    "area_to_m2" numeric,
    "price_from" numeric,
    "price_to" numeric,
    "currency" text,
    "typical_image_url" text,
    "unit_bedrooms" text,
    "bedrooms_amount" text,
    "units_amount" integer default 0,
    "typical_unit_image_url" text,
    "unit_type" text,
    "price_currency" text default 'AED'::text,
    "units_area_from" numeric,
    "units_area_to" numeric,
    "units_price_from_aed" numeric,
    "units_price_to_aed" numeric,
    "units_area_from_m2" numeric,
    "units_area_to_m2" numeric,
    "units_price_from" numeric,
    "units_price_to" numeric
      );



  create table "public"."property_vectors" (
    "id" integer not null,
    "source_id" smallint,
    "external_id" text,
    "slug" text,
    "internal_slug" text,
    "name" text not null,
    "area" text,
    "city" text,
    "country" text,
    "status" text,
    "readiness" numeric,
    "sale_status" text,
    "completion_datetime" timestamp with time zone,
    "furnishing" text,
    "parking" text,
    "service_charge" text,
    "has_escrow" boolean default false,
    "post_handover" boolean default false,
    "is_partner_project" boolean default false,
    "overview" text,
    "min_price_aed" numeric,
    "max_price_aed" numeric,
    "price_currency" text default 'AED'::text,
    "min_area" numeric,
    "max_area" numeric,
    "area_unit" text,
    "developer_id" integer,
    "developer_name" text,
    "developer_description" text,
    "developer_email" text,
    "developer_website" text,
    "unit_types_summary" jsonb default '[]'::jsonb,
    "unit_types_text" text,
    "facilities" text[] default ARRAY[]::text[],
    "facilities_text" text,
    "payment_plans_summary" jsonb default '[]'::jsonb,
    "payment_plans_text" text,
    "buildings_summary" jsonb default '[]'::jsonb,
    "buildings_text" text,
    "nearby_points" jsonb default '[]'::jsonb,
    "nearby_points_text" text,
    "images_summary" jsonb default '{}'::jsonb,
    "image_count" integer default 0,
    "primary_image_url" text,
    "searchable_text" text,
    "embedding" vector(768),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "embedding_status" text default 'pending'::text,
    "embedding_created_at" timestamp with time zone,
    "embedding_updated_at" timestamp with time zone,
    "embedding_model" text default 'text-embedding-3-small'::text,
    "embedding_dimensions" integer default 768,
    "embedding_error" text
      );



  create table "public"."raw_partner_markers" (
    "source_id" smallint not null,
    "external_id" text not null,
    "raw" jsonb not null,
    "fetched_at" timestamp with time zone not null default now(),
    "content_hash" text not null
      );



  create table "public"."raw_partner_properties" (
    "source_id" smallint not null,
    "external_id" text not null,
    "raw" jsonb not null,
    "fetched_at" timestamp with time zone not null default now(),
    "content_hash" text not null,
    "status" text default 'pending'::text
      );



  create table "public"."saved_searches" (
    "id" integer not null default nextval('saved_searches_id_seq'::regclass),
    "user_id" text not null,
    "session_id" text,
    "name" text not null,
    "description" text,
    "search_criteria" jsonb not null,
    "last_query" text,
    "result_count" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "last_executed_at" timestamp with time zone,
    "is_active" boolean default true,
    "alert_enabled" boolean default false
      );


alter table "public"."saved_searches" enable row level security;


  create table "public"."staging_partner_markers_flat" (
    "source_id" smallint not null,
    "external_id" text not null,
    "name" text,
    "area" text,
    "developer" text,
    "status" text,
    "sale_status" text,
    "completion_date" text,
    "min_price" numeric,
    "coordinates_raw" text,
    "latitude" numeric,
    "longitude" numeric,
    "cover_url" text,
    "updated_at" timestamp with time zone not null default now(),
    "developer_id" integer,
    "is_partner_project" boolean
      );



  create table "public"."staging_partner_properties_flat" (
    "source_id" smallint not null,
    "external_id" text not null,
    "name" text,
    "area" text,
    "area_unit" text,
    "developer" text,
    "status" text,
    "sale_status" text,
    "completion_datetime" text,
    "post_handover" boolean,
    "has_escrow" boolean,
    "price_currency" text,
    "min_price" numeric,
    "min_price_aed" numeric,
    "coordinates_raw" text,
    "latitude" numeric,
    "longitude" numeric,
    "cover_url" text,
    "is_partner_project" boolean,
    "updated_at" timestamp with time zone not null default now(),
    "developer_id" integer,
    "developer_website" text,
    "slug" text,
    "country" text,
    "city" text,
    "overview" text,
    "furnishing" text,
    "parking" text,
    "service_charge" text,
    "readiness" text,
    "max_price" numeric,
    "max_price_aed" numeric,
    "max_area" numeric,
    "min_area" numeric,
    "brochure_url" text,
    "layouts_pdf" text,
    "video_url" text,
    "website" text
      );



  create table "public"."waitlist" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "email" text
      );



  create table "public"."whatsapp_agents" (
    "created_at" timestamp with time zone not null default now(),
    "refresh_token" text,
    "access_token" text,
    "whatsapp_business_account" text not null,
    "is_verify" boolean default false,
    "name" text
      );


alter sequence "public"."accounts_id_seq" owned by "public"."accounts"."id";

alter sequence "public"."asset_migration_jobs_id_seq" owned by "public"."asset_migration_jobs"."id";

alter sequence "public"."data_sources_id_seq" owned by "public"."data_sources"."id";

alter sequence "public"."partner_developers_id_seq" owned by "public"."partner_developers"."id";

alter sequence "public"."partner_ingest_tasks_id_seq" owned by "public"."partner_ingest_tasks"."id";

alter sequence "public"."partner_ingest_tracker_id_seq" owned by "public"."partner_ingest_tracker"."id";

alter sequence "public"."properties_id_seq" owned by "public"."properties"."id";

alter sequence "public"."property_buildings_id_seq" owned by "public"."property_buildings"."id";

alter sequence "public"."property_payment_plans_id_seq" owned by "public"."property_payment_plans"."id";

alter sequence "public"."property_unit_blocks_id_seq" owned by "public"."property_unit_blocks"."id";

alter sequence "public"."saved_searches_id_seq" owned by "public"."saved_searches"."id";


CREATE UNIQUE INDEX accounts_email_key ON public.accounts USING btree (email);

CREATE UNIQUE INDEX accounts_pkey ON public.accounts USING btree (id);

CREATE UNIQUE INDEX accounts_user_id_key ON public.accounts USING btree (user_id);

CREATE UNIQUE INDEX asset_migration_jobs_pkey ON public.asset_migration_jobs USING btree (id);

CREATE UNIQUE INDEX bookmarks_pkey ON public.bookmarks USING btree (user_id, property_id);

CREATE UNIQUE INDEX chat_feedback_pkey ON public.chat_feedback USING btree (id);

CREATE UNIQUE INDEX chat_history_pkey ON public.chat_history USING btree (chat_id);

CREATE UNIQUE INDEX data_sources_code_key ON public.data_sources USING btree (code);

CREATE UNIQUE INDEX data_sources_pkey ON public.data_sources USING btree (id);

CREATE UNIQUE INDEX facilities_pkey ON public.facilities USING btree (id);

CREATE UNIQUE INDEX guest_history_pkey ON public.guest_history USING btree (id);

CREATE INDEX idx_asset_migration_jobs_pending ON public.asset_migration_jobs USING btree (created_at) WHERE (status = 'pending'::text);

CREATE INDEX idx_asset_migration_jobs_property ON public.asset_migration_jobs USING btree (property_id);

CREATE INDEX idx_asset_migration_jobs_status ON public.asset_migration_jobs USING btree (status);

CREATE INDEX idx_asset_migration_jobs_type_status ON public.asset_migration_jobs USING btree (asset_type, status);

CREATE INDEX idx_chat_feedback_account_id ON public.chat_feedback USING btree (account_id);

CREATE INDEX idx_chat_feedback_chat_id ON public.chat_feedback USING btree (chat_id);

CREATE INDEX idx_chat_feedback_type ON public.chat_feedback USING btree (feedback);

CREATE INDEX idx_partner_developers_name ON public.partner_developers USING btree (name);

CREATE INDEX idx_partner_ingest_tracker_source ON public.partner_ingest_tracker USING btree (source_id);

CREATE INDEX idx_partner_tasks_source_status_created ON public.partner_ingest_tasks USING btree (source_id, status, created_at);

CREATE INDEX idx_partner_tasks_status_created ON public.partner_ingest_tasks USING btree (status, created_at);

CREATE INDEX idx_properties_brochure_migration ON public.properties USING btree (id) WHERE ((brochure_url_original IS NOT NULL) AND (brochure_url_migrated IS NULL));

CREATE INDEX idx_properties_content_hash ON public.properties USING btree (content_hash);

CREATE INDEX idx_properties_internal_slug ON public.properties USING btree (internal_slug);

CREATE INDEX idx_properties_layouts_migration ON public.properties USING btree (id) WHERE ((layouts_pdf_original IS NOT NULL) AND (layouts_pdf_migrated IS NULL));

CREATE INDEX idx_properties_location_gist ON public.properties USING gist (location);

CREATE INDEX idx_properties_name ON public.properties USING btree (name);

CREATE INDEX idx_properties_raw_data ON public.properties USING gin (raw_data);

CREATE INDEX idx_property_buildings_property ON public.property_buildings USING btree (property_id);

CREATE INDEX idx_property_images_display_order ON public.property_images USING btree (property_id, display_order);

CREATE INDEX idx_property_images_property ON public.property_images USING btree (property_id);

CREATE INDEX idx_property_payment_plans_property ON public.property_payment_plans USING btree (property_id);

CREATE INDEX idx_property_unit_blocks_bedrooms ON public.property_unit_blocks USING btree (unit_bedrooms);

CREATE INDEX idx_property_unit_blocks_property ON public.property_unit_blocks USING btree (property_id);

CREATE INDEX idx_property_vectors_area ON public.property_vectors USING btree (area);

CREATE INDEX idx_property_vectors_area_range ON public.property_vectors USING btree (min_area, max_area);

CREATE INDEX idx_property_vectors_city ON public.property_vectors USING btree (city);

CREATE INDEX idx_property_vectors_developer_id ON public.property_vectors USING btree (developer_id);

CREATE INDEX idx_property_vectors_embedding_hnsw ON public.property_vectors USING hnsw (embedding vector_cosine_ops) WITH (m='16', ef_construction='64');

CREATE INDEX idx_property_vectors_embedding_status ON public.property_vectors USING btree (embedding_status) WHERE (embedding_status = ANY (ARRAY['pending'::text, 'failed'::text]));

CREATE INDEX idx_property_vectors_facilities_gin ON public.property_vectors USING gin (facilities);

CREATE INDEX idx_property_vectors_internal_slug ON public.property_vectors USING btree (internal_slug);

CREATE INDEX idx_property_vectors_price_range ON public.property_vectors USING btree (min_price_aed, max_price_aed);

CREATE INDEX idx_property_vectors_sale_status ON public.property_vectors USING btree (sale_status);

CREATE INDEX idx_property_vectors_searchable_text_gin ON public.property_vectors USING gin (to_tsvector('english'::regconfig, searchable_text));

CREATE INDEX idx_property_vectors_status ON public.property_vectors USING btree (status);

CREATE INDEX idx_property_vectors_updated_at ON public.property_vectors USING btree (updated_at);

CREATE INDEX idx_raw_partner_properties_status ON public.raw_partner_properties USING btree (status);

CREATE INDEX idx_raw_partner_properties_status_fetched ON public.raw_partner_properties USING btree (status, fetched_at);

CREATE INDEX idx_saved_searches_active ON public.saved_searches USING btree (is_active) WHERE (is_active = true);

CREATE INDEX idx_saved_searches_alert_enabled ON public.saved_searches USING btree (alert_enabled) WHERE (alert_enabled = true);

CREATE INDEX idx_saved_searches_created_at ON public.saved_searches USING btree (created_at DESC);

CREATE INDEX idx_saved_searches_session_id ON public.saved_searches USING btree (session_id) WHERE (session_id IS NOT NULL);

CREATE INDEX idx_saved_searches_user_id ON public.saved_searches USING btree (user_id) WHERE (is_active = true);

CREATE INDEX idx_staging_partner_properties_title ON public.staging_partner_properties_flat USING btree (name);

CREATE INDEX idx_staging_partner_props_developer ON public.staging_partner_properties_flat USING btree (developer_id);

CREATE INDEX idx_staging_partner_props_slug ON public.staging_partner_properties_flat USING btree (slug);

CREATE INDEX idx_temp_conversations_created_at ON public.guest_history USING btree (created_at DESC);

CREATE INDEX idx_temp_conversations_session_id ON public.guest_history USING btree (session_id);

CREATE INDEX idx_unit_blocks_prop ON public.property_unit_blocks USING btree (property_id);

CREATE UNIQUE INDEX partner_developers_pkey ON public.partner_developers USING btree (id);

CREATE UNIQUE INDEX partner_developers_source_name_unique ON public.partner_developers USING btree (source_id, name);

CREATE UNIQUE INDEX partner_ingest_tasks_pkey ON public.partner_ingest_tasks USING btree (id);

CREATE UNIQUE INDEX partner_ingest_tasks_source_id_external_id_key ON public.partner_ingest_tasks USING btree (source_id, external_id);

CREATE UNIQUE INDEX partner_ingest_tracker_pkey ON public.partner_ingest_tracker USING btree (id);

CREATE UNIQUE INDEX partner_ingest_tracker_source_unique ON public.partner_ingest_tracker USING btree (source_id);

CREATE UNIQUE INDEX properties_pkey1 ON public.properties USING btree (id);

CREATE UNIQUE INDEX properties_source_external_unique ON public.properties USING btree (source_id, external_id);

CREATE UNIQUE INDEX property_buildings_pkey ON public.property_buildings USING btree (id);

CREATE UNIQUE INDEX property_facilities_pkey1 ON public.property_facilities USING btree (property_id, facility_id);

CREATE INDEX property_images_category_idx ON public.property_images USING btree (category);

CREATE UNIQUE INDEX property_images_pkey1 ON public.property_images USING btree (property_id, image_url);

CREATE INDEX property_images_source_id_idx ON public.property_images USING btree (source_id);

CREATE UNIQUE INDEX property_map_points_duplicate2_pkey ON public.property_map_points USING btree (id);

CREATE INDEX property_map_points_duplicate2_property_id_idx ON public.property_map_points USING btree (property_id);

CREATE UNIQUE INDEX property_map_points_duplicate2_property_id_source_id_name_key ON public.property_map_points USING btree (property_id, source_id, name);

CREATE UNIQUE INDEX property_payment_plans_pkey ON public.property_payment_plans USING btree (id);

CREATE UNIQUE INDEX property_unit_blocks_pkey ON public.property_unit_blocks USING btree (id);

CREATE UNIQUE INDEX property_unit_blocks_property_id_source_id_external_id_key ON public.property_unit_blocks USING btree (property_id, source_id, external_id);

CREATE UNIQUE INDEX property_vectors_pkey ON public.property_vectors USING btree (id);

CREATE UNIQUE INDEX raw_partner_markers_pkey ON public.raw_partner_markers USING btree (source_id, external_id);

CREATE UNIQUE INDEX raw_partner_properties_pkey ON public.raw_partner_properties USING btree (source_id, external_id);

CREATE UNIQUE INDEX saved_searches_pkey ON public.saved_searches USING btree (id);

CREATE UNIQUE INDEX staging_partner_markers_flat_pkey ON public.staging_partner_markers_flat USING btree (source_id, external_id);

CREATE UNIQUE INDEX staging_partner_properties_flat_pkey ON public.staging_partner_properties_flat USING btree (source_id, external_id);

CREATE UNIQUE INDEX unique_feedback_per_message ON public.chat_feedback USING btree (chat_id, message_index, account_id);

CREATE UNIQUE INDEX waitlist_pkey ON public.waitlist USING btree (id);

CREATE UNIQUE INDEX whatsapp_business_pkey ON public.whatsapp_agents USING btree (whatsapp_business_account);

alter table "public"."accounts" add constraint "accounts_pkey" PRIMARY KEY using index "accounts_pkey";

alter table "public"."asset_migration_jobs" add constraint "asset_migration_jobs_pkey" PRIMARY KEY using index "asset_migration_jobs_pkey";

alter table "public"."bookmarks" add constraint "bookmarks_pkey" PRIMARY KEY using index "bookmarks_pkey";

alter table "public"."chat_feedback" add constraint "chat_feedback_pkey" PRIMARY KEY using index "chat_feedback_pkey";

alter table "public"."chat_history" add constraint "chat_history_pkey" PRIMARY KEY using index "chat_history_pkey";

alter table "public"."data_sources" add constraint "data_sources_pkey" PRIMARY KEY using index "data_sources_pkey";

alter table "public"."facilities" add constraint "facilities_pkey" PRIMARY KEY using index "facilities_pkey";

alter table "public"."guest_history" add constraint "guest_history_pkey" PRIMARY KEY using index "guest_history_pkey";

alter table "public"."partner_developers" add constraint "partner_developers_pkey" PRIMARY KEY using index "partner_developers_pkey";

alter table "public"."partner_ingest_tasks" add constraint "partner_ingest_tasks_pkey" PRIMARY KEY using index "partner_ingest_tasks_pkey";

alter table "public"."partner_ingest_tracker" add constraint "partner_ingest_tracker_pkey" PRIMARY KEY using index "partner_ingest_tracker_pkey";

alter table "public"."properties" add constraint "properties_pkey1" PRIMARY KEY using index "properties_pkey1";

alter table "public"."property_buildings" add constraint "property_buildings_pkey" PRIMARY KEY using index "property_buildings_pkey";

alter table "public"."property_facilities" add constraint "property_facilities_pkey1" PRIMARY KEY using index "property_facilities_pkey1";

alter table "public"."property_images" add constraint "property_images_pkey1" PRIMARY KEY using index "property_images_pkey1";

alter table "public"."property_map_points" add constraint "property_map_points_duplicate2_pkey" PRIMARY KEY using index "property_map_points_duplicate2_pkey";

alter table "public"."property_payment_plans" add constraint "property_payment_plans_pkey" PRIMARY KEY using index "property_payment_plans_pkey";

alter table "public"."property_unit_blocks" add constraint "property_unit_blocks_pkey" PRIMARY KEY using index "property_unit_blocks_pkey";

alter table "public"."property_vectors" add constraint "property_vectors_pkey" PRIMARY KEY using index "property_vectors_pkey";

alter table "public"."raw_partner_markers" add constraint "raw_partner_markers_pkey" PRIMARY KEY using index "raw_partner_markers_pkey";

alter table "public"."raw_partner_properties" add constraint "raw_partner_properties_pkey" PRIMARY KEY using index "raw_partner_properties_pkey";

alter table "public"."saved_searches" add constraint "saved_searches_pkey" PRIMARY KEY using index "saved_searches_pkey";

alter table "public"."staging_partner_markers_flat" add constraint "staging_partner_markers_flat_pkey" PRIMARY KEY using index "staging_partner_markers_flat_pkey";

alter table "public"."staging_partner_properties_flat" add constraint "staging_partner_properties_flat_pkey" PRIMARY KEY using index "staging_partner_properties_flat_pkey";

alter table "public"."waitlist" add constraint "waitlist_pkey" PRIMARY KEY using index "waitlist_pkey";

alter table "public"."whatsapp_agents" add constraint "whatsapp_business_pkey" PRIMARY KEY using index "whatsapp_business_pkey";

alter table "public"."accounts" add constraint "accounts_email_key" UNIQUE using index "accounts_email_key";

alter table "public"."accounts" add constraint "accounts_user_id_key" UNIQUE using index "accounts_user_id_key";

alter table "public"."asset_migration_jobs" add constraint "asset_migration_jobs_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."asset_migration_jobs" validate constraint "asset_migration_jobs_property_id_fkey";

alter table "public"."asset_migration_jobs" add constraint "asset_migration_jobs_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text, 'skipped'::text]))) not valid;

alter table "public"."asset_migration_jobs" validate constraint "asset_migration_jobs_status_check";

alter table "public"."bookmarks" add constraint "bookmarks_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) not valid;

alter table "public"."bookmarks" validate constraint "bookmarks_property_id_fkey";

alter table "public"."bookmarks" add constraint "bookmarks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES accounts(user_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."bookmarks" validate constraint "bookmarks_user_id_fkey";

alter table "public"."chat_feedback" add constraint "chat_feedback_account_id_fkey" FOREIGN KEY (account_id) REFERENCES accounts(user_id) ON DELETE SET NULL not valid;

alter table "public"."chat_feedback" validate constraint "chat_feedback_account_id_fkey";

alter table "public"."chat_feedback" add constraint "chat_feedback_feedback_check" CHECK ((feedback = ANY (ARRAY['up'::text, 'down'::text]))) not valid;

alter table "public"."chat_feedback" validate constraint "chat_feedback_feedback_check";

alter table "public"."chat_feedback" add constraint "unique_feedback_per_message" UNIQUE using index "unique_feedback_per_message";

alter table "public"."chat_history" add constraint "chat_history_account_id_fkey" FOREIGN KEY (account_id) REFERENCES accounts(user_id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."chat_history" validate constraint "chat_history_account_id_fkey";

alter table "public"."data_sources" add constraint "data_sources_code_key" UNIQUE using index "data_sources_code_key";

alter table "public"."partner_developers" add constraint "partner_developers_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON DELETE CASCADE not valid;

alter table "public"."partner_developers" validate constraint "partner_developers_source_id_fkey";

alter table "public"."partner_developers" add constraint "partner_developers_source_name_unique" UNIQUE using index "partner_developers_source_name_unique";

alter table "public"."partner_ingest_tasks" add constraint "partner_ingest_tasks_source_id_external_id_key" UNIQUE using index "partner_ingest_tasks_source_id_external_id_key";

alter table "public"."partner_ingest_tasks" add constraint "partner_ingest_tasks_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) not valid;

alter table "public"."partner_ingest_tasks" validate constraint "partner_ingest_tasks_source_id_fkey";

alter table "public"."partner_ingest_tasks" add constraint "partner_ingest_tasks_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'processing'::text, 'done'::text, 'error'::text]))) not valid;

alter table "public"."partner_ingest_tasks" validate constraint "partner_ingest_tasks_status_check";

alter table "public"."partner_ingest_tracker" add constraint "partner_ingest_tracker_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON DELETE CASCADE not valid;

alter table "public"."partner_ingest_tracker" validate constraint "partner_ingest_tracker_source_id_fkey";

alter table "public"."partner_ingest_tracker" add constraint "partner_ingest_tracker_source_unique" UNIQUE using index "partner_ingest_tracker_source_unique";

alter table "public"."properties" add constraint "properties_developer_id_fkey" FOREIGN KEY (developer_id) REFERENCES partner_developers(id) ON DELETE SET NULL not valid;

alter table "public"."properties" validate constraint "properties_developer_id_fkey";

alter table "public"."properties" add constraint "properties_source_external_unique" UNIQUE using index "properties_source_external_unique";

alter table "public"."properties" add constraint "properties_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON DELETE CASCADE not valid;

alter table "public"."properties" validate constraint "properties_source_id_fkey";

alter table "public"."property_buildings" add constraint "property_buildings_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_buildings" validate constraint "property_buildings_property_id_fkey";

alter table "public"."property_facilities" add constraint "property_facilities_facility_id_fkey1" FOREIGN KEY (facility_id) REFERENCES facilities(id) not valid;

alter table "public"."property_facilities" validate constraint "property_facilities_facility_id_fkey1";

alter table "public"."property_facilities" add constraint "property_facilities_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_facilities" validate constraint "property_facilities_property_id_fkey";

alter table "public"."property_images" add constraint "property_images_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_images" validate constraint "property_images_property_id_fkey";

alter table "public"."property_map_points" add constraint "property_map_points_duplicate2_property_id_source_id_name_key" UNIQUE using index "property_map_points_duplicate2_property_id_source_id_name_key";

alter table "public"."property_map_points" add constraint "property_map_points_duplicate2_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) not valid;

alter table "public"."property_map_points" validate constraint "property_map_points_duplicate2_source_id_fkey";

alter table "public"."property_map_points" add constraint "property_map_points_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_map_points" validate constraint "property_map_points_property_id_fkey";

alter table "public"."property_payment_plans" add constraint "property_payment_plans_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_payment_plans" validate constraint "property_payment_plans_property_id_fkey";

alter table "public"."property_unit_blocks" add constraint "property_unit_blocks_property_id_fkey" FOREIGN KEY (property_id) REFERENCES properties(id) ON DELETE CASCADE not valid;

alter table "public"."property_unit_blocks" validate constraint "property_unit_blocks_property_id_fkey";

alter table "public"."property_unit_blocks" add constraint "property_unit_blocks_property_id_source_id_external_id_key" UNIQUE using index "property_unit_blocks_property_id_source_id_external_id_key";

alter table "public"."property_vectors" add constraint "fk_property_vectors_developer" FOREIGN KEY (developer_id) REFERENCES partner_developers(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."property_vectors" validate constraint "fk_property_vectors_developer";

alter table "public"."property_vectors" add constraint "fk_property_vectors_property" FOREIGN KEY (id) REFERENCES properties(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."property_vectors" validate constraint "fk_property_vectors_property";

alter table "public"."property_vectors" add constraint "fk_property_vectors_source" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid;

alter table "public"."property_vectors" validate constraint "fk_property_vectors_source";

alter table "public"."property_vectors" add constraint "property_vectors_embedding_status_check" CHECK ((embedding_status = ANY (ARRAY['pending'::text, 'processing'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."property_vectors" validate constraint "property_vectors_embedding_status_check";

alter table "public"."raw_partner_markers" add constraint "raw_partner_markers_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON DELETE CASCADE not valid;

alter table "public"."raw_partner_markers" validate constraint "raw_partner_markers_source_id_fkey";

alter table "public"."raw_partner_properties" add constraint "raw_partner_properties_source_id_fkey" FOREIGN KEY (source_id) REFERENCES data_sources(id) ON DELETE CASCADE not valid;

alter table "public"."raw_partner_properties" validate constraint "raw_partner_properties_source_id_fkey";

alter table "public"."saved_searches" add constraint "check_description_length" CHECK ((char_length(description) <= 1000)) not valid;

alter table "public"."saved_searches" validate constraint "check_description_length";

alter table "public"."saved_searches" add constraint "check_name_length" CHECK (((char_length(name) >= 1) AND (char_length(name) <= 200))) not valid;

alter table "public"."saved_searches" validate constraint "check_name_length";

alter table "public"."staging_partner_markers_flat" add constraint "staging_partner_markers_flat_developer_id_fkey" FOREIGN KEY (developer_id) REFERENCES partner_developers(id) not valid;

alter table "public"."staging_partner_markers_flat" validate constraint "staging_partner_markers_flat_developer_id_fkey";

alter table "public"."staging_partner_properties_flat" add constraint "staging_partner_properties_flat_developer_id_fkey" FOREIGN KEY (developer_id) REFERENCES partner_developers(id) not valid;

alter table "public"."staging_partner_properties_flat" validate constraint "staging_partner_properties_flat_developer_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.claim_partner_tasks(p_source_code text, p_batch integer DEFAULT 25)
 RETURNS TABLE(id bigint, source_id smallint, external_id text)
 LANGUAGE plpgsql
AS $function$
declare
  v_source_id smallint;
  task_record record;
begin
  -- Get source_id
  select id into v_source_id from public.data_sources where code = p_source_code;
  if v_source_id is null then
    raise exception 'Unknown source_code: %', p_source_code using errcode = '22023';
  end if;

  -- Process tasks one by one to avoid ambiguity
  for task_record in 
    select 
      partner_ingest_tasks.id,
      partner_ingest_tasks.source_id,
      partner_ingest_tasks.external_id
    from public.partner_ingest_tasks
    where partner_ingest_tasks.source_id = v_source_id
      and partner_ingest_tasks.status = 'pending'
    order by partner_ingest_tasks.created_at
    limit coalesce(p_batch, 25)
    for update skip locked
  loop
    -- Update the task to processing
    update public.partner_ingest_tasks
    set status = 'processing',
        attempts = attempts + 1,
        claimed_at = now(),
        updated_at = now()
    where partner_ingest_tasks.id = task_record.id;
    
    -- Return the task
    id := task_record.id;
    source_id := task_record.source_id;
    external_id := task_record.external_id;
    return next;
  end loop;
  
  return;
end$function$
;

CREATE OR REPLACE FUNCTION public.claim_raw_archive_tasks(p_source_code text, p_batch integer DEFAULT 25)
 RETURNS TABLE(id bigint, source_id smallint, external_id text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_source_id smallint;
BEGIN
  -- Get source_id from code
  SELECT ds.id INTO v_source_id
  FROM data_sources ds
  WHERE ds.code = p_source_code;

  IF v_source_id IS NULL THEN
    RAISE EXCEPTION 'Unknown source code: %', p_source_code;
  END IF;

  -- Claim pending tasks
  RETURN QUERY
  WITH sel AS (
    SELECT t.id
    FROM public.claim_partner_tasks t
    WHERE t.source_id = v_source_id
      AND t.status = 'pending'
    ORDER BY t.created_at
    FOR UPDATE SKIP LOCKED
    LIMIT COALESCE(p_batch, 25)
  ),
  upd AS (
    UPDATE public.claim_partner_tasks t
    SET 
      status = 'processing',
      attempts = COALESCE(t.attempts, 0) + 1,
      claimed_at = NOW()
    FROM sel
    WHERE t.id = sel.id
    RETURNING t.id, t.source_id, t.external_id
  )
  SELECT u.id, u.source_id, u.external_id
  FROM upd u;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.claim_tasks_safe(p_source_code text, p_batch integer DEFAULT 25)
 RETURNS TABLE(task_id bigint, source_id smallint, external_id text)
 LANGUAGE plpgsql
AS $function$
declare
  v_source_id smallint;
  task_record record;
begin
  -- Get source_id
  select id into v_source_id from public.data_sources where code = p_source_code;
  if v_source_id is null then
    raise exception 'Unknown source_code: %', p_source_code using errcode = '22023';
  end if;

  -- Process tasks one by one
  for task_record in 
    select 
      pit.id,
      pit.source_id,
      pit.external_id
    from public.partner_ingest_tasks pit
    where pit.source_id = v_source_id
      and pit.status = 'pending'
    order by pit.created_at
    limit coalesce(p_batch, 25)
    for update skip locked
  loop
    -- Update the task to processing
    update public.partner_ingest_tasks pit
    set status = 'processing',
        attempts = pit.attempts + 1,
        claimed_at = now(),
        updated_at = now()
    where pit.id = task_record.id;
    
    -- Return the task
    task_id := task_record.id;
    source_id := task_record.source_id;
    external_id := task_record.external_id;
    return next;
  end loop;
  
  return;
end$function$
;

CREATE OR REPLACE FUNCTION public.clean_and_reset_properties()
 RETURNS TABLE(step text, action text, count_deleted bigint)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_properties BIGINT;
  v_images BIGINT;
  v_buildings BIGINT;
  v_units BIGINT;
  v_plans BIGINT;
  v_facilities BIGINT;
  v_map_points BIGINT;
  v_raw_updated BIGINT;
BEGIN
  -- Get counts before deletion
  SELECT COUNT(*) INTO v_images FROM property_images;
  SELECT COUNT(*) INTO v_buildings FROM property_buildings;
  SELECT COUNT(*) INTO v_units FROM property_unit_blocks;
  SELECT COUNT(*) INTO v_plans FROM property_payment_plans;
  SELECT COUNT(*) INTO v_facilities FROM property_facilities;
  SELECT COUNT(*) INTO v_map_points FROM property_map_points;
  SELECT COUNT(*) INTO v_properties FROM properties;

  -- Delete all child records
  DELETE FROM property_images;
  DELETE FROM property_buildings;
  DELETE FROM property_unit_blocks;
  DELETE FROM property_payment_plans;
  DELETE FROM property_facilities;
  DELETE FROM property_map_points;

  -- Delete all properties
  DELETE FROM properties;

  -- Reset raw properties to pending
  UPDATE raw_partner_properties SET status = 'pending';
  GET DIAGNOSTICS v_raw_updated = ROW_COUNT;

  -- Notify PostgREST to reload schema
  PERFORM pg_notify('pgrst', 'reload schema');

  -- Return summary
  RETURN QUERY
  SELECT '1_deleted'::TEXT, 'property_images'::TEXT, v_images
  UNION ALL
  SELECT '1_deleted'::TEXT, 'property_buildings'::TEXT, v_buildings
  UNION ALL
  SELECT '1_deleted'::TEXT, 'property_unit_blocks'::TEXT, v_units
  UNION ALL
  SELECT '1_deleted'::TEXT, 'property_payment_plans'::TEXT, v_plans
  UNION ALL
  SELECT '1_deleted'::TEXT, 'property_facilities'::TEXT, v_facilities
  UNION ALL
  SELECT '1_deleted'::TEXT, 'property_map_points'::TEXT, v_map_points
  UNION ALL
  SELECT '1_deleted'::TEXT, 'properties'::TEXT, v_properties
  UNION ALL
  SELECT '2_reset'::TEXT, 'raw_partner_properties â†’ pending'::TEXT, v_raw_updated
  ORDER BY step, action;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.count_user_saved_searches(p_user_id text)
 RETURNS integer
 LANGUAGE sql
 STABLE
AS $function$
  SELECT COUNT(*)::INTEGER
  FROM saved_searches
  WHERE user_id = p_user_id
    AND is_active = TRUE;
$function$
;

CREATE OR REPLACE FUNCTION public.end_sync_run(p_run_id bigint, p_new integer DEFAULT 0, p_updated integer DEFAULT 0, p_enriched integer DEFAULT 0, p_media integer DEFAULT 0, p_errors integer DEFAULT 0, p_notes text DEFAULT NULL::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
begin
  update sync_runs
     set finished_at   = now(),
         new_count     = coalesce(new_count,0)     + coalesce(p_new,0),
         updated_count = coalesce(updated_count,0) + coalesce(p_updated,0),
         enriched_count= coalesce(enriched_count,0)+ coalesce(p_enriched,0),
         media_added   = coalesce(media_added,0)   + coalesce(p_media,0),
         error_count   = coalesce(error_count,0)   + coalesce(p_errors,0),
         notes         = coalesce(notes,'') || coalesce('\n'||p_notes,'')
   where id = p_run_id;
end $function$
;

CREATE OR REPLACE FUNCTION public.execute_sql(query text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  result JSONB;
  query_upper TEXT;
  query_normalized TEXT;
BEGIN
  -- Security checks
  query_upper := UPPER(TRIM(query));
  
  -- NEW: Normalize all whitespace (including newlines) to single spaces
  -- This fixes the regex issue with multi-line SQL
  query_normalized := regexp_replace(query_upper, '\s+', ' ', 'g');
  
  -- Check 1: Must start with SELECT
  IF NOT query_normalized LIKE 'SELECT%' THEN
    RAISE EXCEPTION 'Only SELECT queries allowed';
  END IF;
  
  -- Check 2: Block dangerous keywords (using normalized query)
  IF query_normalized ~* '\b(DROP|DELETE|UPDATE|INSERT|ALTER|CREATE|TRUNCATE|GRANT|REVOKE|EXECUTE|MERGE|REPLACE)\b' THEN
    RAISE EXCEPTION 'Forbidden SQL operation detected';
  END IF;
  
  -- Check 3: Block multiple statements (semicolons)
  IF query ~ ';.+' THEN
    RAISE EXCEPTION 'Multiple statements not allowed';
  END IF;
  
  -- Check 4: Block comments
  IF query ~ '--' OR query ~ '/\*' THEN
    RAISE EXCEPTION 'Comments not allowed in queries';
  END IF;
  
  -- Check 5: FIXED - Ensure query is against allowed tables (using normalized query)
  -- Now works with multi-line SQL because we normalized whitespace
  -- Use ~* for case-insensitive regex OR use uppercase pattern since query_normalized is uppercase
  IF NOT query_normalized ~* 'FROM (property_vectors|properties|partner_developers|facilities)' THEN
    RAISE EXCEPTION 'Query must use allowed tables only (property_vectors, properties, partner_developers, facilities)';
  END IF;
  
  -- Execute the query and return results as JSONB array
  BEGIN
    EXECUTE format('SELECT jsonb_agg(t) FROM (%s) t', query) INTO result;
    
    -- If no results, return empty array
    IF result IS NULL THEN
      result := '[]'::jsonb;
    END IF;
    
    RETURN result;
    
  EXCEPTION WHEN OTHERS THEN
    -- Log the error and return it
    RAISE WARNING 'SQL execution error: %', SQLERRM;
    RAISE EXCEPTION 'Query execution failed: %', SQLERRM;
  END;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.generate_property_slug()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Convert title to lowercase, replace spaces with hyphens, remove special characters
    NEW.slug = LOWER(REGEXP_REPLACE(
        TRIM(NEW.title),
        '[^a-zA-Z0-9\s-]', '', 'g'  -- Remove all characters except letters, numbers, spaces, and hyphens
    ));
    NEW.slug = REGEXP_REPLACE(NEW.slug, '\s+', '-', 'g'); -- Replace one or more spaces with a single hyphen
    NEW.slug = REGEXP_REPLACE(NEW.slug, '-+', '-', 'g');  -- Replace multiple hyphens with a single hyphen
    NEW.slug = TRIM(BOTH '-' FROM NEW.slug);              -- Remove leading/trailing hyphens
    
    RETURN NEW;
END;
$function$
;

create type "public"."geometry_dump" as ("path" integer[], "geom" geometry);

CREATE OR REPLACE FUNCTION public.get_user_saved_searches(p_user_id text)
 RETURNS SETOF saved_searches
 LANGUAGE sql
 STABLE
AS $function$
  SELECT *
  FROM saved_searches
  WHERE user_id = p_user_id
    AND is_active = TRUE
  ORDER BY created_at DESC;
$function$
;

create type "public"."http_header" as ("field" character varying, "value" character varying);

create type "public"."http_request" as ("method" http_method, "uri" character varying, "headers" http_header[], "content_type" character varying, "content" character varying);

create type "public"."http_response" as ("status" integer, "content_type" character varying, "headers" http_header[], "content" character varying);

CREATE OR REPLACE FUNCTION public.hybrid_search_properties(query_text text, query_embedding vector, city_filter text DEFAULT NULL::text, min_price_filter numeric DEFAULT NULL::numeric, max_price_filter numeric DEFAULT NULL::numeric, result_limit integer DEFAULT 10)
 RETURNS TABLE(id integer, name text, area text, city text, min_price_aed numeric, searchable_text text, vector_distance double precision, text_rank double precision, combined_score double precision)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    WITH vector_results AS (
        SELECT 
            pv.id,
            (pv.embedding <=> query_embedding) AS distance
        FROM property_vectors pv
        WHERE pv.embedding IS NOT NULL
        ORDER BY distance
        LIMIT result_limit * 2
    ),
    text_results AS (
        SELECT 
            pv.id,
            ts_rank_cd(to_tsvector('english', pv.searchable_text), 
                      plainto_tsquery('english', query_text)) AS rank
        FROM property_vectors pv
        WHERE to_tsvector('english', pv.searchable_text) @@ plainto_tsquery('english', query_text)
        ORDER BY rank DESC
        LIMIT result_limit * 2
    )
    SELECT 
        pv.id,
        pv.name,
        pv.area,
        pv.city,
        pv.min_price_aed,
        pv.searchable_text,
        COALESCE(vr.distance, 1.0) AS vector_distance,
        COALESCE(tr.rank, 0.0) AS text_rank,
        -- Reciprocal Rank Fusion score
        (1.0 / (60 + COALESCE(vr.distance * 100, 1000))) + 
        (1.0 / (60 + CASE WHEN tr.rank > 0 THEN 1.0/tr.rank ELSE 1000 END)) AS combined_score
    FROM property_vectors pv
    LEFT JOIN vector_results vr ON pv.id = vr.id
    LEFT JOIN text_results tr ON pv.id = tr.id
    WHERE 
        (vr.id IS NOT NULL OR tr.id IS NOT NULL)
        AND (city_filter IS NULL OR pv.city = city_filter)
        AND (min_price_filter IS NULL OR pv.min_price_aed >= min_price_filter)
        AND (max_price_filter IS NULL OR pv.max_price_aed <= max_price_filter)
    ORDER BY combined_score DESC
    LIMIT result_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.migrate_images_to_r2_batch()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  rec record;
  batch_count int := 0;
  weserv_url text;
  img_data bytea;
  r2_key text;
  r2_final_url text;
  upload_resp http_response;
begin
  -- Check if there is any work to do
  perform 1 from property_images where new_url is null limit 1;
  if not found then
    raise notice 'No images left to migrate. Job stopping itself.';
    return;
  end if;

  raise notice 'Starting batch â€“ found pending images';

  for rec in
    select property_id, image_url, name, display_order
    from property_images
    where new_url is null
    order by property_id, display_order
    limit 15
  loop
    begin
      -- Optimize with weserv.nl
      weserv_url := 'https://images.weserv.nl/?url=' ||
        encode_uri_component(rec.image_url) ||
        '&w=1600&h=1600&q=80&output=webp&af=&il=';

      select content into img_data
      from http_get(weserv_url)
      where status = 200 and content_length > 500;

      if img_data is null then
        raise notice 'Weserv failed for property_id=%', rec.property_id;
        continue;
      end if;

      -- Generate clean filename
      r2_key := 'properties/' || rec.property_id || '/' ||
        coalesce(
          regexp_replace(rec.name, '[^a-zA-Z0-9.-]+', '_', 'g'),
          'img-' || rec.display_order
        ) || '.webp';

      r2_final_url := 'https://pub-aeebdca4653c4608a35fe97f85704590.r2.dev/' || r2_key;

      -- Upload directly using your R2 API Token (no presigned URL hell!)
      upload_resp := http((
        'PUT',
        'https://5060491a57fcdb57b18328ea13e56c6c.r2.cloudflarestorage.com/prop8t/' || r2_key,
        ARRAY[
          http_header('Content-Type', 'image/webp'),
          http_header('Authorization', 'Bearer ' || current_setting('r2.token'))
        ],
        'image/webp',
        img_data
      ));

      if upload_resp.status = 200 then
        update property_images
        set new_url = r2_final_url
        where property_id = rec.property_id
          and image_url = rec.image_url;

        batch_count := batch_count + 1;
        raise notice 'Success: property_id=% â†’ %', rec.property_id, r2_final_url;
      else
        raise notice 'R2 upload failed: % %', upload_resp.status, upload_resp.content::text;
      end if;

    exception when others then
      raise notice 'Error on property_id=%: %', rec.property_id, sqlerrm;
    end;
  end loop;

  raise notice 'Batch completed â€“ migrated % images', batch_count;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.rebuild_all_property_vectors()
 RETURNS TABLE(property_id integer, status text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_property_id integer;
  v_count integer := 0;
  v_total integer;
BEGIN
  -- Get total count
  SELECT count(*) INTO v_total FROM properties;
  
  RAISE NOTICE 'Starting rebuild of % properties...', v_total;
  
  -- Loop through all properties
  FOR v_property_id IN 
    SELECT id FROM properties ORDER BY id
  LOOP
    BEGIN
      PERFORM rebuild_property_vector(v_property_id);
      v_count := v_count + 1;
      
      -- Progress logging every 100 properties
      IF v_count % 100 = 0 THEN
        RAISE NOTICE 'Progress: %/%', v_count, v_total;
      END IF;
      
      property_id := v_property_id;
      status := 'success';
      RETURN NEXT;
      
    EXCEPTION WHEN OTHERS THEN
      property_id := v_property_id;
      status := 'error: ' || SQLERRM;
      RETURN NEXT;
    END;
  END LOOP;
  
  RAISE NOTICE 'Completed rebuild of % properties', v_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.rebuild_property_vector(p_property_id integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_property record;
  v_developer record;
  v_unit_types jsonb;
  v_unit_types_text text;
  v_facilities text[];
  v_facilities_text text;
  v_payment_plans jsonb;
  v_payment_plans_text text;
  v_buildings jsonb;
  v_buildings_text text;
  v_nearby_points jsonb;
  v_nearby_points_text text;
  v_images_summary jsonb;
  v_image_count integer;
  v_primary_image text;
  v_searchable_text text;
BEGIN
  SELECT * INTO v_property FROM properties WHERE id = p_property_id;
  IF NOT FOUND THEN RETURN; END IF;
  
  IF v_property.developer_id IS NOT NULL THEN
    SELECT * INTO v_developer FROM partner_developers WHERE id = v_property.developer_id;
  END IF;
  
  -- THIS IS THE FIXED UNIT TYPES AGGREGATION
  SELECT 
    jsonb_build_object(
      'available_bedrooms', jsonb_agg(DISTINCT unit_bedrooms ORDER BY unit_bedrooms),
      'unit_types', jsonb_agg(
        jsonb_build_object(
          'normalized_type', normalized_type,
          'unit_bedrooms', unit_bedrooms,
          'bedrooms_amount', bedrooms_amount,
          'units_amount', units_amount,
          'area_unit', area_unit,
          'units_area_from_m2', units_area_from_m2,
          'units_area_to_m2', units_area_to_m2,
          'units_price_from_aed', units_price_from_aed,
          'units_price_to_aed', units_price_to_aed,
          'price_currency', COALESCE(price_currency, 'AED'),
          'area_range', 
            CASE 
              WHEN units_area_from_m2 IS NOT NULL AND units_area_to_m2 IS NOT NULL 
              THEN units_area_from_m2::text || '-' || units_area_to_m2::text || ' mÂ²'
              ELSE NULL
            END,
          'price_range',
            CASE 
              WHEN units_price_from_aed IS NOT NULL AND units_price_to_aed IS NOT NULL 
              THEN 
                CASE 
                  WHEN units_price_from_aed >= 1000000 
                  THEN ROUND(units_price_from_aed / 1000000, 2)::text || 'M-' || 
                       ROUND(units_price_to_aed / 1000000, 2)::text || 'M AED'
                  ELSE ROUND(units_price_from_aed / 1000, 0)::text || 'K-' || 
                       ROUND(units_price_to_aed / 1000, 0)::text || 'K AED'
                END
              WHEN units_price_from_aed IS NOT NULL
              THEN 
                CASE 
                  WHEN units_price_from_aed >= 1000000 
                  THEN ROUND(units_price_from_aed / 1000000, 2)::text || 'M AED'
                  ELSE ROUND(units_price_from_aed / 1000, 0)::text || 'K AED'
                END
              ELSE NULL
            END
        ) ORDER BY bedrooms_amount, normalized_type
      ),
      'total_units', SUM(COALESCE(units_amount, 0))
    )
  INTO v_unit_types
  FROM property_unit_blocks
  WHERE property_id = p_property_id;
  
  SELECT string_agg(name || ' (' || COALESCE(units_amount::text || ' units', 'units') ||
    COALESCE(', ' || units_area_from::text || '-' || units_area_to::text || ' ' || area_unit, '') ||
    COALESCE(', ' || 
      CASE WHEN units_price_from_aed >= 1000000 
        THEN ROUND(units_price_from_aed / 1000000, 2)::text || 'M-' || ROUND(units_price_to_aed / 1000000, 2)::text || 'M AED'
        ELSE ROUND(units_price_from_aed / 1000, 0)::text || 'K-' || ROUND(units_price_to_aed / 1000, 0)::text || 'K AED'
      END, '') || ')', ', ')
  INTO v_unit_types_text FROM property_unit_blocks WHERE property_id = p_property_id;
  
  SELECT array_agg(f.name ORDER BY f.name), 'Facilities: ' || string_agg(f.name, ', ' ORDER BY f.name)
  INTO v_facilities, v_facilities_text
  FROM property_facilities pf JOIN facilities f ON f.id = pf.facility_id WHERE pf.property_id = p_property_id;
  
  SELECT jsonb_build_object('available_plans', jsonb_agg(DISTINCT plan_name), 'has_payment_plan', bool_or(true),
    'plans', jsonb_agg(jsonb_build_object('name', plan_name, 'payments', payments, 'post_handover_months', months_after_handover)))
  INTO v_payment_plans FROM property_payment_plans WHERE property_id = p_property_id;
  
  SELECT 'Payment options: ' || string_agg(plan_name || 
    CASE WHEN months_after_handover > 0 THEN ' with ' || months_after_handover::text || '-month post-handover' ELSE '' END, ', ')
  INTO v_payment_plans_text FROM property_payment_plans WHERE property_id = p_property_id;
  
  SELECT jsonb_build_object('building_count', count(*), 'buildings', 
    jsonb_agg(jsonb_build_object('name', name, 'completion_date', completion_date) ORDER BY name))
  INTO v_buildings FROM property_buildings WHERE property_id = p_property_id;
  
  SELECT 'Buildings: ' || string_agg(name || CASE WHEN completion_date IS NOT NULL 
    THEN ' (completion ' || completion_date || ')' ELSE '' END, ', ' ORDER BY name)
  INTO v_buildings_text FROM property_buildings WHERE property_id = p_property_id;
  
  SELECT jsonb_agg(jsonb_build_object('name', name, 'distance_km', distance_km) ORDER BY distance_km)
  INTO v_nearby_points FROM (SELECT name, distance_km FROM property_map_points 
    WHERE property_id = p_property_id ORDER BY distance_km LIMIT 10) subquery;
  
  SELECT 'Nearby: ' || string_agg(name || ' (' || distance_km::text || 'km)', ', ')
  INTO v_nearby_points_text FROM (SELECT name, distance_km FROM property_map_points 
    WHERE property_id = p_property_id ORDER BY distance_km LIMIT 10) subquery;
  
  SELECT jsonb_build_object('total_images', count(*), 'categories', 
    jsonb_object_agg(COALESCE(category, 'uncategorized'), cat_count), 'primary_image', MIN(image_url)),
    count(*)::integer, MIN(image_url)
  INTO v_images_summary, v_image_count, v_primary_image
  FROM (SELECT category, image_url, count(*) OVER (PARTITION BY category) as cat_count 
    FROM property_images WHERE property_id = p_property_id) img_data;
  
  v_searchable_text := 
    COALESCE(v_property.name, '') || '. ' || COALESCE(v_property.area, '') || ', ' || 
    COALESCE(v_property.city, '') || ', ' || COALESCE(v_property.country, '') || '. ' ||
    CASE WHEN v_developer.name IS NOT NULL 
      THEN 'Developed by ' || v_developer.name || COALESCE(' - ' || v_developer.description, '') || '. ' ELSE '' END ||
    COALESCE(v_property.status, '') || ' property' ||
    CASE WHEN v_property.readiness IS NOT NULL THEN ' with ' || v_property.readiness::text || '% completion' ELSE '' END ||
    CASE WHEN v_property.completion_datetime IS NOT NULL 
      THEN ', expected ' || to_char(v_property.completion_datetime, 'Mon YYYY') ELSE '' END || '. ' ||
    CASE WHEN v_property.furnishing IS NOT NULL THEN v_property.furnishing || ' units available. ' ELSE '' END ||
    'Overview: ' || COALESCE(v_property.overview, '') || ' ' ||
    CASE WHEN v_unit_types_text IS NOT NULL THEN 'Available units: ' || v_unit_types_text || '. ' ELSE '' END ||
    COALESCE(v_facilities_text || '. ', '') || COALESCE(v_payment_plans_text || '. ', '') ||
    COALESCE(v_buildings_text || '. ', '') || COALESCE(v_nearby_points_text || '. ', '') ||
    'Price range: ' ||
    CASE WHEN v_property.min_price_aed IS NOT NULL AND v_property.max_price_aed IS NOT NULL THEN
      CASE WHEN v_property.min_price_aed >= 1000000 
        THEN ROUND(v_property.min_price_aed / 1000000, 2)::text || 'M-' || ROUND(v_property.max_price_aed / 1000000, 2)::text || 'M AED'
        ELSE ROUND(v_property.min_price_aed / 1000, 0)::text || 'K-' || ROUND(v_property.max_price_aed / 1000, 0)::text || 'K AED'
      END ELSE 'Contact for pricing' END || '. ' ||
    'Area range: ' ||
    CASE WHEN v_property.min_area IS NOT NULL AND v_property.max_area IS NOT NULL 
      THEN v_property.min_area::text || '-' || v_property.max_area::text || ' ' || COALESCE(v_property.area_unit, 'sqft')
      ELSE 'varies' END || '. ' ||
    CASE WHEN v_property.parking IS NOT NULL THEN 'Parking: ' || v_property.parking || '. ' ELSE '' END ||
    CASE WHEN v_property.service_charge IS NOT NULL THEN 'Service charge: ' || v_property.service_charge || '. ' ELSE '' END ||
    CASE WHEN v_property.has_escrow THEN 'Escrow account available. ' ELSE '' END ||
    CASE WHEN v_property.post_handover THEN 'Post-handover payment options. ' ELSE '' END;
  
  INSERT INTO property_vectors (
    id, source_id, external_id, slug, internal_slug, name, area, city, country,
    status, readiness, sale_status, completion_datetime, furnishing, parking, service_charge, 
    has_escrow, post_handover, is_partner_project, overview,
    min_price_aed, max_price_aed, price_currency, min_area, max_area, area_unit,
    developer_id, developer_name, developer_description, developer_email, developer_website,
    unit_types_summary, unit_types_text, facilities, facilities_text,
    payment_plans_summary, payment_plans_text, buildings_summary, buildings_text,
    nearby_points, nearby_points_text, images_summary, image_count, primary_image_url,
    searchable_text, updated_at
  )
  VALUES (
    v_property.id, v_property.source_id, v_property.external_id, v_property.slug, v_property.internal_slug,
    v_property.name, v_property.area, v_property.city, v_property.country,
    v_property.status, v_property.readiness, v_property.sale_status, v_property.completion_datetime,
    v_property.furnishing, v_property.parking, v_property.service_charge, 
    v_property.has_escrow, v_property.post_handover, v_property.is_partner_project, v_property.overview,
    v_property.min_price_aed, v_property.max_price_aed, v_property.price_currency,
    v_property.min_area, v_property.max_area, v_property.area_unit,
    v_developer.id, v_developer.name, v_developer.description, v_developer.email, v_developer.website,
    v_unit_types, v_unit_types_text, v_facilities, v_facilities_text,
    v_payment_plans, v_payment_plans_text, v_buildings, v_buildings_text,
    v_nearby_points, v_nearby_points_text, v_images_summary, v_image_count, v_primary_image,
    v_searchable_text, now()
  )
  ON CONFLICT (id) DO UPDATE SET
    source_id = EXCLUDED.source_id, external_id = EXCLUDED.external_id,
    slug = EXCLUDED.slug, internal_slug = EXCLUDED.internal_slug,
    name = EXCLUDED.name, area = EXCLUDED.area, city = EXCLUDED.city, country = EXCLUDED.country,
    status = EXCLUDED.status, readiness = EXCLUDED.readiness, sale_status = EXCLUDED.sale_status,
    completion_datetime = EXCLUDED.completion_datetime, furnishing = EXCLUDED.furnishing,
    parking = EXCLUDED.parking, service_charge = EXCLUDED.service_charge,
    has_escrow = EXCLUDED.has_escrow, post_handover = EXCLUDED.post_handover,
    is_partner_project = EXCLUDED.is_partner_project, overview = EXCLUDED.overview,
    min_price_aed = EXCLUDED.min_price_aed, max_price_aed = EXCLUDED.max_price_aed,
    price_currency = EXCLUDED.price_currency, min_area = EXCLUDED.min_area,
    max_area = EXCLUDED.max_area, area_unit = EXCLUDED.area_unit,
    developer_id = EXCLUDED.developer_id, developer_name = EXCLUDED.developer_name,
    developer_description = EXCLUDED.developer_description, developer_email = EXCLUDED.developer_email,
    developer_website = EXCLUDED.developer_website, unit_types_summary = EXCLUDED.unit_types_summary,
    unit_types_text = EXCLUDED.unit_types_text, facilities = EXCLUDED.facilities,
    facilities_text = EXCLUDED.facilities_text, payment_plans_summary = EXCLUDED.payment_plans_summary,
    payment_plans_text = EXCLUDED.payment_plans_text, buildings_summary = EXCLUDED.buildings_summary,
    buildings_text = EXCLUDED.buildings_text, nearby_points = EXCLUDED.nearby_points,
    nearby_points_text = EXCLUDED.nearby_points_text, images_summary = EXCLUDED.images_summary,
    image_count = EXCLUDED.image_count, primary_image_url = EXCLUDED.primary_image_url,
    searchable_text = EXCLUDED.searchable_text, updated_at = now();
END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_properties_nearby(center_lat double precision, center_lng double precision, radius_meters integer DEFAULT 5000, price_min numeric DEFAULT NULL::numeric, price_max numeric DEFAULT NULL::numeric, result_limit integer DEFAULT 50)
 RETURNS TABLE(id integer, name text, area text, city text, coordinates_text text, min_price_aed numeric, max_price_aed numeric, distance_meters double precision)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    p.id,
    p.name,
    p.area,
    p.city,
    p.coordinates_text,
    p.min_price_aed,
    p.max_price_aed,
    ST_Distance(
      p.location,
      ST_SetSRID(ST_MakePoint(center_lng, center_lat), 4326)::GEOGRAPHY
    )::FLOAT as distance_meters
  FROM public.properties p
  WHERE p.location IS NOT NULL
    -- ST_DWithin uses GIST index for fast filtering (O(log n))
    AND ST_DWithin(
      p.location,
      ST_SetSRID(ST_MakePoint(center_lng, center_lat), 4326)::GEOGRAPHY,
      radius_meters
    )
    -- Apply optional price filters
    AND (price_min IS NULL OR p.min_price_aed >= price_min)
    AND (price_max IS NULL OR p.max_price_aed <= price_max)
  -- Order by distance (nearest first)
  ORDER BY distance_meters ASC
  LIMIT result_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.simple_vector_search(query_embedding vector, filters jsonb DEFAULT '{}'::jsonb, result_limit integer DEFAULT 10)
 RETURNS TABLE(id integer, name text, area text, city text, min_price_aed numeric, max_price_aed numeric, developer_name text, facilities text[], searchable_text text, distance double precision)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pv.id,
        pv.name,
        pv.area,
        pv.city,
        pv.min_price_aed,
        pv.max_price_aed,
        pv.developer_name,
        pv.facilities,
        pv.searchable_text,
        (pv.embedding <=> query_embedding) AS distance
    FROM property_vectors pv
    WHERE 
        pv.embedding IS NOT NULL
        AND (filters->>'city' IS NULL OR pv.city = filters->>'city')
        AND (filters->>'min_price' IS NULL OR pv.min_price_aed >= (filters->>'min_price')::numeric)
        AND (filters->>'max_price' IS NULL OR pv.max_price_aed <= (filters->>'max_price')::numeric)
    ORDER BY distance
    LIMIT result_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.tg_set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at := now();
  return new;
end$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_buildings()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_developer()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_property_id integer;
BEGIN
  IF TG_OP = 'UPDATE' THEN
    -- Update all properties for this developer
    FOR v_property_id IN 
      SELECT id FROM properties WHERE developer_id = NEW.id
    LOOP
      PERFORM rebuild_property_vector(v_property_id);
    END LOOP;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_facilities()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_images()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_map_points()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_payment_plans()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_property()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    -- CASCADE FK will handle deletion
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    PERFORM rebuild_property_vector(NEW.id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_sync_vectors_on_unit_blocks()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM rebuild_property_vector(OLD.property_id);
    RETURN OLD;
  ELSE
    PERFORM rebuild_property_vector(NEW.property_id);
    RETURN NEW;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trigger_migration_batch()
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  remaining_count int;
  service_key constant text := 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InN2YXB5emNmbGRoZXltYWhpb29yIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1ODI3MTMyNCwiZXhwIjoyMDczODQ3MzI0fQ.ndxbJXFMqlsbWmQm_ly7NPkk_58lgaiv0wI3yW3x-lc';  -- Your service_role key here
  edge_url constant text := 'https://svapyzcfldheymahioor.supabase.co/functions/v1/clever-worker';  -- Replace YOUR_PROJECT_REF (e.g., abcde123)
begin
  -- Count remaining images
  select count(*) into remaining_count from property_images where new_url is null;
  
  if remaining_count = 0 then
    perform cron.unschedule('auto-migrate-cron');  -- Auto-stop the cron job
    raise notice 'Migration complete! Cron job stopped.';
    return;
  end if;
  
  -- Call Edge Function via pg_net HTTP POST
  perform net.http_post(
    url := edge_url,
    headers := jsonb_build_object(
      'Authorization', 'Bearer ' || service_key,
      'Content-Type', 'application/json'
    ),
    body := '{}'::jsonb,
    timeout_milliseconds := 50000  -- 30s timeout
  );
  
  raise notice 'Triggered batch for % remaining images', remaining_count;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.update_location_from_coordinates()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only update if coordinates_text is valid (not null, not empty, proper format)
  IF NEW.coordinates_text IS NOT NULL 
     AND NEW.coordinates_text != '' 
     AND TRIM(NEW.coordinates_text) != ''
     AND NEW.coordinates_text ~ '^[0-9]+\.[0-9]+, [0-9]+\.[0-9]+$' THEN
    BEGIN
      NEW.location = ST_SetSRID(
        ST_MakePoint(
          CAST(SPLIT_PART(NEW.coordinates_text, ', ', 2) AS FLOAT),  -- longitude
          CAST(SPLIT_PART(NEW.coordinates_text, ', ', 1) AS FLOAT)   -- latitude
        ), 4326)::GEOGRAPHY;
    EXCEPTION
      WHEN OTHERS THEN
        -- If cast fails, set location to NULL and continue
        NEW.location = NULL;
    END;
  ELSE
    NEW.location = NULL;
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_saved_searches_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

create type "public"."valid_detail" as ("valid" boolean, "reason" character varying, "location" geometry);

CREATE OR REPLACE FUNCTION public.vector_search_properties(query_embedding vector, city_filter text DEFAULT NULL::text, area_filter text DEFAULT NULL::text, min_price_filter numeric DEFAULT NULL::numeric, max_price_filter numeric DEFAULT NULL::numeric, min_area_filter numeric DEFAULT NULL::numeric, max_area_filter numeric DEFAULT NULL::numeric, status_filter text DEFAULT NULL::text, sale_status_filter text DEFAULT NULL::text, bedrooms_filter text DEFAULT NULL::text, required_facilities text[] DEFAULT NULL::text[], result_limit integer DEFAULT 10, result_offset integer DEFAULT 0)
 RETURNS TABLE(id integer, source_id smallint, external_id text, slug text, internal_slug text, name text, area text, city text, country text, status text, readiness numeric, sale_status text, completion_datetime timestamp with time zone, furnishing text, parking text, service_charge text, has_escrow boolean, post_handover boolean, is_partner_project boolean, overview text, min_price_aed numeric, max_price_aed numeric, price_currency text, min_area numeric, max_area numeric, area_unit text, developer_id integer, developer_name text, developer_description text, developer_email text, developer_website text, unit_types_summary jsonb, unit_types_text text, facilities text[], facilities_text text, payment_plans_summary jsonb, payment_plans_text text, buildings_summary jsonb, buildings_text text, nearby_points jsonb, nearby_points_text text, images_summary jsonb, image_count integer, primary_image_url text, searchable_text text, embedding_status text, embedding_created_at timestamp with time zone, embedding_updated_at timestamp with time zone, embedding_model text, embedding_dimensions integer, created_at timestamp with time zone, updated_at timestamp with time zone, distance double precision)
 LANGUAGE plpgsql
 STABLE
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        pv.id,
        pv.source_id,
        pv.external_id,
        pv.slug,
        pv.internal_slug,
        
        pv.name,
        pv.area,
        pv.city,
        pv.country,
        
        pv.status,
        pv.readiness,
        pv.sale_status,
        pv.completion_datetime,
        
        pv.furnishing,
        pv.parking,
        pv.service_charge,
        pv.has_escrow,
        pv.post_handover,
        pv.is_partner_project,
        
        pv.overview,
        
        pv.min_price_aed,
        pv.max_price_aed,
        pv.price_currency,
        pv.min_area,
        pv.max_area,
        pv.area_unit,
        
        pv.developer_id,
        pv.developer_name,
        pv.developer_description,
        pv.developer_email,
        pv.developer_website,
        
        pv.unit_types_summary,
        pv.unit_types_text,
        pv.facilities,
        pv.facilities_text,
        pv.payment_plans_summary,
        pv.payment_plans_text,
        pv.buildings_summary,
        pv.buildings_text,
        pv.nearby_points,
        pv.nearby_points_text,
        pv.images_summary,
        pv.image_count,
        pv.primary_image_url,
        
        pv.searchable_text,
        
        pv.embedding_status,
        pv.embedding_created_at,
        pv.embedding_updated_at,
        pv.embedding_model,
        pv.embedding_dimensions,
        
        pv.created_at,
        pv.updated_at,
        
        (pv.embedding <=> query_embedding) AS distance
    FROM property_vectors pv
    WHERE 
        pv.embedding IS NOT NULL
        AND (city_filter IS NULL OR pv.city = city_filter)
        AND (area_filter IS NULL OR pv.area = area_filter)
        AND (min_price_filter IS NULL OR pv.min_price_aed >= min_price_filter)
        AND (max_price_filter IS NULL OR pv.max_price_aed <= max_price_filter)
        AND (min_area_filter IS NULL OR pv.min_area >= min_area_filter)
        AND (max_area_filter IS NULL OR pv.max_area <= max_area_filter)
        AND (status_filter IS NULL OR pv.status = status_filter)
        AND (sale_status_filter IS NULL OR pv.sale_status = sale_status_filter)
        AND (bedrooms_filter IS NULL OR pv.unit_types_summary->'available_bedrooms' @> to_jsonb(bedrooms_filter))
        AND (required_facilities IS NULL OR pv.facilities @> required_facilities)
    ORDER BY distance
    LIMIT result_limit
    OFFSET result_offset;
END;
$function$
;


  create policy "Users can insert own feedback"
  on "public"."chat_feedback"
  as permissive
  for insert
  to public
with check (((auth.uid() = account_id) OR (account_id IS NULL)));



  create policy "Users can update own feedback"
  on "public"."chat_feedback"
  as permissive
  for update
  to public
using ((auth.uid() = account_id))
with check ((auth.uid() = account_id));



  create policy "Users can view own feedback"
  on "public"."chat_feedback"
  as permissive
  for select
  to public
using (((auth.uid() = account_id) OR (account_id IS NULL)));



  create policy "saved_searches_delete_own"
  on "public"."saved_searches"
  as permissive
  for delete
  to public
using ((((auth.uid())::text = user_id) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text)));



  create policy "saved_searches_insert_own"
  on "public"."saved_searches"
  as permissive
  for insert
  to public
with check ((((auth.uid())::text = user_id) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text)));



  create policy "saved_searches_select_own"
  on "public"."saved_searches"
  as permissive
  for select
  to public
using ((((auth.uid())::text = user_id) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text)));



  create policy "saved_searches_update_own"
  on "public"."saved_searches"
  as permissive
  for update
  to public
using ((((auth.uid())::text = user_id) OR ((auth.jwt() ->> 'role'::text) = 'service_role'::text)));


CREATE TRIGGER trg_developers_sync_vectors AFTER UPDATE ON public.partner_developers FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_developer();

CREATE TRIGGER trg_partner_developers_updated_at BEFORE UPDATE ON public.partner_developers FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();

CREATE TRIGGER trg_partner_ingest_tasks_updated_at BEFORE UPDATE ON public.partner_ingest_tasks FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();

CREATE TRIGGER trg_partner_ingest_tracker_updated_at BEFORE UPDATE ON public.partner_ingest_tracker FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();

CREATE TRIGGER trg_properties_sync_vectors AFTER INSERT OR UPDATE ON public.properties FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_property();

CREATE TRIGGER trg_properties_update_location BEFORE INSERT OR UPDATE OF coordinates_text ON public.properties FOR EACH ROW EXECUTE FUNCTION update_location_from_coordinates();

CREATE TRIGGER trg_properties_updated_at BEFORE UPDATE ON public.properties FOR EACH ROW EXECUTE FUNCTION tg_set_updated_at();

CREATE TRIGGER trg_buildings_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_buildings FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_buildings();

CREATE TRIGGER trg_facilities_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_facilities FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_facilities();

CREATE TRIGGER trg_images_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_images FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_images();

CREATE TRIGGER trg_map_points_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_map_points FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_map_points();

CREATE TRIGGER trg_payment_plans_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_payment_plans FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_payment_plans();

CREATE TRIGGER trg_unit_blocks_sync_vectors AFTER INSERT OR DELETE OR UPDATE ON public.property_unit_blocks FOR EACH ROW EXECUTE FUNCTION trg_sync_vectors_on_unit_blocks();

CREATE TRIGGER trg_saved_searches_updated_at BEFORE UPDATE ON public.saved_searches FOR EACH ROW EXECUTE FUNCTION update_saved_searches_updated_at();


